"""gRPC server for agent host pod.

This service runs on each agent host pod and handles agent lifecycle
management via gRPC RPCs.
"""

import grpc
import json
import logging
import os
import threading
import time
from concurrent import futures
from typing import Dict, Any

import redis

from rustic_ai.core.guild.agent import AgentSpec
from rustic_ai.core.guild.dsl import GuildSpec
from rustic_ai.core.guild.execution.process_manager import AgentProcessManager
from rustic_ai.core.messaging import MessagingConfig
from rustic_ai.k8s.registry.location_registry import AgentLocationRegistry

# Import generated gRPC stubs (will be generated by scripts/generate_protos.sh)
try:
    from rustic_ai.k8s.proto import agent_host_pb2, agent_host_pb2_grpc
except ImportError:
    # Stubs not generated yet - will be available after running generate_protos.sh
    agent_host_pb2 = None
    agent_host_pb2_grpc = None

logger = logging.getLogger(__name__)


class AgentHostServicer:
    """
    gRPC service implementation for agent host.

    This servicer:
    - Uses AgentProcessManager for process lifecycle
    - Uses AgentLocationRegistry for location tracking
    - Runs heartbeat worker thread
    - Implements all 5 gRPC RPCs
    """

    def __init__(
        self,
        redis_client: redis.Redis,
        max_processes: int = 100,
        heartbeat_interval: int = 20,
    ):
        """
        Initialize the agent host servicer.

        Args:
            redis_client: Redis client for location registry
            max_processes: Maximum number of agent processes to allow
            heartbeat_interval: Seconds between heartbeat refreshes
        """
        self.process_manager = AgentProcessManager(max_processes=max_processes)
        self.location_registry = AgentLocationRegistry(redis_client)

        # Get hostname for registration (K8s pod name)
        self.hostname = os.getenv("HOSTNAME", "localhost")
        self.grpc_port = int(os.getenv("GRPC_PORT", "50051"))
        self.my_address = f"{self.hostname}:{self.grpc_port}"

        self.heartbeat_interval = heartbeat_interval
        self.heartbeat_thread = None
        self.shutdown_requested = False

        logger.info(
            f"AgentHostServicer initialized: "
            f"address={self.my_address}, max_processes={max_processes}"
        )

    def CreateAgent(self, request, context):
        """
        Create and start a new agent process.

        Args:
            request: CreateAgentRequest with serialized specs
            context: gRPC context

        Returns:
            CreateAgentResponse with agent_id and success status
        """
        try:
            # Deserialize specs from JSON
            agent_spec_dict = json.loads(request.agent_spec.decode('utf-8'))
            guild_spec_dict = json.loads(request.guild_spec.decode('utf-8'))
            messaging_config_dict = json.loads(request.messaging_config.decode('utf-8'))
            client_properties = json.loads(request.client_properties.decode('utf-8'))

            # Reconstruct Pydantic models
            agent_spec = AgentSpec(**agent_spec_dict)
            guild_spec = GuildSpec(**guild_spec_dict)
            messaging_config = MessagingConfig(**messaging_config_dict)

            logger.info(f"Creating agent {agent_spec.id} on {self.my_address}")

            # Spawn the agent process
            agent_id = self.process_manager.spawn_agent_process(
                agent_spec=agent_spec,
                guild_spec=guild_spec,
                messaging_config=messaging_config,
                machine_id=request.machine_id,
                client_type_name=request.client_type,
                client_properties=client_properties,
            )

            # Register location in Redis
            self.location_registry.register(agent_id, self.my_address)

            # Get process info
            process_info = self.process_manager.get_process_info(agent_id)
            pid = process_info.pid if process_info else 0

            logger.info(
                f"Successfully created agent {agent_id} "
                f"(pid={pid}) on {self.my_address}"
            )

            return agent_host_pb2.CreateAgentResponse(
                agent_id=agent_id,
                pid=pid,
                success=True,
                error=""
            )

        except Exception as e:
            logger.error(f"Failed to create agent: {e}", exc_info=True)
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return agent_host_pb2.CreateAgentResponse(
                agent_id="",
                pid=0,
                success=False,
                error=str(e)
            )

    def StopAgent(self, request, context):
        """
        Stop a running agent process.

        Args:
            request: StopAgentRequest with agent_id and timeout
            context: gRPC context

        Returns:
            StopAgentResponse with success status
        """
        try:
            agent_id = request.agent_id
            timeout = request.timeout if request.timeout > 0 else 10

            logger.info(f"Stopping agent {agent_id} (timeout={timeout}s)")

            # Stop the process
            success = self.process_manager.stop_agent_process(agent_id, timeout=timeout)

            if success:
                # Deregister from location registry
                self.location_registry.deregister(agent_id)
                logger.info(f"Successfully stopped agent {agent_id}")
            else:
                logger.warning(f"Agent {agent_id} not found or already stopped")

            return agent_host_pb2.StopAgentResponse(
                success=success,
                error="" if success else f"Agent {agent_id} not found"
            )

        except Exception as e:
            logger.error(f"Failed to stop agent {request.agent_id}: {e}", exc_info=True)
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return agent_host_pb2.StopAgentResponse(
                success=False,
                error=str(e)
            )

    def GetAgentInfo(self, request, context):
        """
        Get information about a specific agent.

        Args:
            request: GetAgentInfoRequest with agent_id
            context: gRPC context

        Returns:
            AgentInfo with agent details
        """
        try:
            agent_id = request.agent_id
            process_info = self.process_manager.get_process_info(agent_id)

            if not process_info:
                context.set_code(grpc.StatusCode.NOT_FOUND)
                context.set_details(f"Agent {agent_id} not found")
                return agent_host_pb2.AgentInfo()

            return agent_host_pb2.AgentInfo(
                agent_id=process_info.agent_id,
                guild_id=process_info.guild_id,
                agent_name=process_info.agent_name,
                pid=process_info.pid,
                is_alive=process_info.is_alive,
                created_at=int(process_info.created_at)
            )

        except Exception as e:
            logger.error(f"Failed to get agent info for {request.agent_id}: {e}")
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return agent_host_pb2.AgentInfo()

    def ListAgents(self, request, context):
        """
        List all agents running on this host.

        Args:
            request: ListAgentsRequest with optional guild_id filter
            context: gRPC context

        Returns:
            ListAgentsResponse with list of AgentInfo
        """
        try:
            guild_id = request.guild_id if request.guild_id else None
            processes = self.process_manager.list_processes(guild_id=guild_id)

            agents = []
            for agent_id, process_info in processes.items():
                agents.append(
                    agent_host_pb2.AgentInfo(
                        agent_id=process_info.agent_id,
                        guild_id=process_info.guild_id,
                        agent_name=process_info.agent_name,
                        pid=process_info.pid,
                        is_alive=process_info.is_alive,
                        created_at=int(process_info.created_at)
                    )
                )

            logger.debug(
                f"Listed {len(agents)} agents "
                f"(guild_id={guild_id if guild_id else 'all'})"
            )

            return agent_host_pb2.ListAgentsResponse(agents=agents)

        except Exception as e:
            logger.error(f"Failed to list agents: {e}", exc_info=True)
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return agent_host_pb2.ListAgentsResponse(agents=[])

    def Health(self, request, context):
        """
        Health check for the agent host.

        Args:
            request: HealthRequest (empty)
            context: gRPC context

        Returns:
            HealthResponse with health status and agent count
        """
        try:
            processes = self.process_manager.list_processes()
            agent_count = len(processes)

            return agent_host_pb2.HealthResponse(
                healthy=True,
                agent_count=agent_count,
                hostname=self.hostname
            )

        except Exception as e:
            logger.error(f"Health check failed: {e}")
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return agent_host_pb2.HealthResponse(
                healthy=False,
                agent_count=0,
                hostname=self.hostname
            )

    def start_heartbeat_worker(self):
        """Start the background heartbeat worker thread."""
        if self.heartbeat_thread and self.heartbeat_thread.is_alive():
            logger.warning("Heartbeat worker already running")
            return

        def heartbeat_loop():
            """Background thread that refreshes agent location TTLs."""
            logger.info(
                f"Heartbeat worker started (interval={self.heartbeat_interval}s)"
            )

            while not self.shutdown_requested:
                try:
                    # Get all local agent processes
                    processes = self.process_manager.list_processes()

                    for agent_id, process_info in processes.items():
                        if process_info.is_alive:
                            # Refresh TTL for alive agents
                            success = self.location_registry.heartbeat(agent_id)
                            if not success:
                                logger.warning(
                                    f"Heartbeat failed for {agent_id} "
                                    f"(location entry may have expired)"
                                )
                        else:
                            # Deregister dead agents
                            logger.info(f"Agent {agent_id} is dead, deregistering")
                            self.location_registry.deregister(agent_id)

                    # Cleanup dead processes
                    cleaned = self.process_manager.cleanup_dead_processes()
                    if cleaned:
                        logger.info(f"Cleaned up {len(cleaned)} dead processes")

                except Exception as e:
                    logger.error(f"Error in heartbeat worker: {e}", exc_info=True)

                # Sleep until next heartbeat
                for _ in range(self.heartbeat_interval):
                    if self.shutdown_requested:
                        break
                    time.sleep(1)

            logger.info("Heartbeat worker stopped")

        self.heartbeat_thread = threading.Thread(
            target=heartbeat_loop,
            daemon=True,
            name="heartbeat-worker"
        )
        self.heartbeat_thread.start()

    def shutdown(self):
        """Shutdown the agent host servicer."""
        logger.info("Shutting down AgentHostServicer")

        # Signal heartbeat worker to stop
        self.shutdown_requested = True

        # Wait for heartbeat thread to finish
        if self.heartbeat_thread and self.heartbeat_thread.is_alive():
            self.heartbeat_thread.join(timeout=5)

        # Shutdown process manager (stops all agents)
        self.process_manager.shutdown()

        logger.info("AgentHostServicer shutdown complete")


def create_grpc_server(servicer: AgentHostServicer, port: int = 50051):
    """
    Create and configure a gRPC server with the agent host servicer.

    Args:
        servicer: AgentHostServicer instance
        port: Port to listen on

    Returns:
        Configured gRPC server (not started)
    """
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))

    # Add servicer to server
    agent_host_pb2_grpc.add_AgentHostServiceServicer_to_server(servicer, server)

    # Bind to port
    server.add_insecure_port(f'[::]:{port}')

    logger.info(f"gRPC server configured on port {port}")

    return server
